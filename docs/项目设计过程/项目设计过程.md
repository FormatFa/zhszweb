
### 主要功能模块开发过程
- 整体开发过程
  - 使用git版本管理系统管理项目
  - 
- 主要功能模块
  - 前端可视化功能
    - 搭建前端项目基本框架
      - 使用vue-CLI 构建项目骨架
      - 引入相关的依赖
      - 编写各个界面路由组件
      - 封装基本http请求api
      - 编写路由跳转,数据传递
      - 编写导航组件
    - 页面布局和图表配置
      - 编写界面图表
      - 根据需要的图，使用测试数据画出图表


  - 后台数据查询api接口编写
    - 后台创建数据库,表
    - 根据前端测试数据的数据格式,编写后端查询数据库语句
    - 前后端连接

  - 可视化导航组件
    - 导航功能
    - 和可视化页面数据交互(->EventBus)
    - 
  - 用户登录注册
    - 未登录拦截
    - 登录注册
    - 修改密码
    - 用户session
  - 数据导入,数据解析 功能
    - 上传数据，获取已上传数据, 删除
    - 前端数据上传
    - 后端处理excel
    - 导入数据库
    - 
  - 问题
    - 前后端数据交互 跨域问题
  - 后期
    - Flask 合并 前端代码
    - 编译部署
  - git 版本管理开发
## 前端可视化功能

## 搭建前端项目基本框架

### 使用vue-CLI 构建项目骨架
  
>Vue-CLI 是 Vue.js 开发的标准工具,用来创建项目的基本骨架

###  引入相关的依赖

###  编写各个界面路由组件
  
 Vue Router 是 Vue.js 官方的路由管理器。

路由和URL的映射主要在  `router.js`  文件,浏览器上访问不同的URL,就会将页面的主页面替换为相应的`组件`
 ```javascript
 const routes =[
    {
      path:"/zhzs/:collegeid",component:College,name:"college"
    },
    {
      path:"/zhzs/:collegeid/:classid/:studentid",component:Student,name:"student"
    },
    {
      path:"/zhzs/:collegeid/:classid",component:Class,name:"class"
    },
    {
      path:"/login",component:Login,name:"login"
    },
    {
      path:"/",component:Data,name:"data"
    },
    {
      path:"/data",component:Data,name:"data"
    },
    {
      path:"/register",component:Register,name:"register"
    }
  ]
  
 ```
- 封装基本http请求api

    图表数据和导航的数据需要从`Flask`后端请求,这就涉及到ajax请求,这里前端请求使用的是axios库,为了方便调用 ,将常用的get,post请求封装成函数。

    1. 封装get,post方法

    2. 设置全局的请求拦截器
      拦截所有请求失败的请求,判断错误码,比如错误码为`401`就就未登录,就重定向到登录界面
      `http.js`
## 页面布局和图表配置
### 编写界面图表
根据需要画各个界面的图表，在各个界面使用测试数据显示图表

0. 列出需要显示的图表列表
   根据数据集的字段，和要分析的维度,列出要显示的图表列表。
   以学院界面为例
  ```
  - 年度和两个学期的综合素质测评平均分（文字） 卡片card

  - 各个指标测评分均分（饼图联动）

	标题: xx年度第y学期 各项指标平均分数
	某个学期的某个各项指标的全部人的平均分

	选某个指标就切换某个指标的数据，不选就全部指标平均分的top

   - 分学期 统计出各项指标个人测评分全院TOP50（表格）
	某指标可以是某项指标或者总分studenttop

  - 分学期 统计出各项指标班级均分TOP5（堆叠柱状图）

	classtop
	xx年度第y学期 某指标 TOP5班级
	某指标可以是某项指标或者总分

  -  分学期 对比 综合素质总分在这区间出现的次数（双柱状图,堆叠）

	xx年度综合素质总各分区间次数分布
	某个年度的，不分学期
	range
		
  - 分学期 GPA成绩与综合素质总分的关系（散点图）
	整个年度,或者某个指标的关系
	gpa_score
	
  - 各个学年 学院平均分变化趋势
	堆叠区域图
	学院各年平均分变化
	trend
  ```
   
1. 绘制界面草图

  界面草图描述了需要的图表在界面中的大概位置,下面为三个主要的可视化界面的草图

  ![学院界面草图](学院界面草图.png)
  ![班级界面草图](班级界面草图.png)
  ![班级界面草图](班级界面草图.png)

2. 使用代码实现草图的布局

   前端UI框架使用`ElementUI`,用它提供的栅格布局可以方便的将界面划分成N行M列,并且可以直接设置列的宽度(图表的宽度),可以轻易的将草图的内容在前端绘制出来

   - 定义一行
   ```html
   <el-row :gutter="40" style="margin-top: 25px;">
   ```
   - 定义一列,span为列的宽度
   ```html
    <el-col :span="5" :xs="24">
   ```
   - 定义图表组件
   ```html
    <v-chart  ref="trend" class="chart" autoresize > </v-chart>
    ```
3. 使用测试数据填充图表
   
  在正式连接后台数据库前,使用测试数据填充图表
   - 看到图表的大致效果
   - 规定数据的结构
   

   为了方便后端查询和前端组装给ECharts,数据格式使用`json`格式

   学院界面测试数据部分格式
   ```js
   export const college={
    //基本信息,通过查询某一年获取
    basicCard:{
        "year_score":123,
        "term1_score":90,
        "term2_score":120
    },
    //某年度，某学期，所有 指标和对应的平均分  xx年y学期
    indexes:{
        //所有的指标
    indexes:["身心健康","思想政治","创新创业"],
    //上面指标对应的分数(平均分)
    scores:[100,200]
    },
    // top 总分学生和班级
    top:{
        //按各个指标或者平均分的排名
        "平均分":{
            //按平均分的top
            classes:[{
                name:"17大数据1班",
                id:"17bigdata1",
                score:129
   ...省略
   ```

   将数据组装成ECharts需要的格式,和填充图表

  班级top图表:
   ```js

  set_classtop(){
     console.log("设置班级top数据:"+this.nowIndex)
      let chart = this.$refs['classtop'];
      
      if(Object.keys(this.data['top']).indexOf(this.nowIndex)==-1)
      {
        console.warn("设置班级top图失败,"+this.nowIndex+"不存在")
        return;
      }
      let classes = this.data['top'][this.nowIndex]['classes']
      let names = [];
      let scores = [];
      classes.forEach(element => {
        names.push(element['name'])
        scores.push(element['score'])
        
      });
      // 倒序，这样显示柱子就是从大到小
      names=names.reverse()
      scores = scores.reverse();

      //查看当前选择的饼图，饼图选择是什么就显示对应的数据
      let option= {
        title: { text: `${this.stateStore.year} 年度 ${this.stateStore.termName()} ${this.nowIndex} TOP5班级` },
        tooltip:{},
       
        grid:{
          left:'20%'
        },
        xAxis: {
          type:"value",
          name:"分数",
          boundaryGap :false,
          axisTick:{
            interval :0
          },
          axisLabel:{
            interval:0
          }

        },
        yAxis: {
          name:"班级",
          type:"category",
          data: names

        },
        series: {
          type: "bar",
          data: scores

        }
      }
      chart.mergeOptions(option);
      
    }

   ```
>这里的通过测试数据规定数据的结构，后面连接后端时,后端根据这个数据结构,查询数据库,使用真实数据返回同样结构的数据,图表就能显示真实的数据

### 编写路由跳转,数据传递
  
  设置各个页面之间的跳转规则, 学院->班级->个人

  跳转方式有两种

  1. 顶部导航跳转
   
  2. 通过图表数据项跳转

      通过监听图表的数据项的点击事件,如饼图的分块,柱状图的柱子

      如学院界面的`平均分Top5班级`图,可以通过点击班级的柱子跳转到对应的班级界面
      - 设置图表的监听事件
      ```html
        <el-col :span="11" :xs="24" >
         <el-card>
        <v-chart  @click="intoClass" class="chart" ref="classtop" autoresize ></v-chart>
         </el-card>
      </el-col>
      ```
      获取点击的值,跳转到班级界面
      ```js
        intoClass(params){
      console.log("进入班级..")
      this.$router.push({
        name:"class",
        params:{
          classid:params.name,
          collegeid:"大数据与人工智能学院"
        }
      })

    }
      ```


## 后台数据查询api接口编写

### 后台创建数据库,表

>后台使用Flask框架,数据库查询修改使用`SQLAlchemy`,`SQL语句`

1. 定义表的Model
   
   用户表和综合素质数据表(`zhsz_api\models.py`)
   ```python
    class User(db.Model, UserMixin):
    '''
    用户模型
    '''
    __tablename__ = 'User'
    id = db.Column(db.Integer, primary_key=True,autoincrement=True)
    username = db.Column(db.String(64), unique=True)
    password = db.Column(db.String(200))

    def __init__(self, **kwargs):
        password = kwargs.pop('password')
        password = bcrypt.generate_password_hash(password)
        kwargs['password'] = password
        super(User, self).__init__(**kwargs)

    def check_password(self, password):
        return bcrypt.check_password_hash(self.password, password)

    def to_json(self):
        return {'id': self.id, 'username': self.username}

    class Bigtable(db.Model,UserMixin):
      #__tablename__='bigdata_ai'
      __tablename__ = 'zhsz'
      primary_id=db.Column(db.Integer,primary_key=True,autoincrement=True)
      style_id=db.Column(db.String(50),nullable=True)  #不能以学号为主键，因为在17级第一学期和第二学期的时候，同一个人会发生主键冲突
      stu_name=db.Column(db.String(100))
      political_edu=db.Column(db.Float)
      physical_heal=db.Column(db.Float)
      innovation_entrep=db.Column(db.Float)
      technical_skills=db.Column(db.Float)
      volunte=db.Column(db.Float)
      human_art=db.Column(db.Float)
      zh_theory=db.Column(db.Float)
      score=db.Column(db.Float)
      GPA=db.Column(db.Float)
      zh_score=db.Column(db.Float)
      gk_class=db.Column(db.String(100))
      grade=db.Column(db.String(50))  #年度 比如这个表是2018年度的
      semester=db.Column(db.String(50))  #学期
      year = db.Column(db.String(50))   #年级比如 17大数据1班，那么就是2017级
      college=db.Column(db.String(50))

   ```
2. 根据前端测试数据的数据格式,编写后端查询数据库语句
   
   >前端已经组装出来了数据的结构，后台现在要做的就是根据数据结构查询出需要的数据，以规定的数据结构返回

   - 定义各个接口界面的接口路由
   - 编写查询数据库语句,组装成规定数据结构返回
   (`zhsz_api\controllers\logonav.py`)
```python
@api_blue.route("/collage",methods=['POST'])
def collage():
    params = request.json
    year=params['year']
    term=params['term']
    college = params['college']
    if term in term_names.keys():
        term = term_names[term]
    print("request,arg",params)
    查询数据
     year_score=Bigtable.query.filter(Bigtable.year==year,Bigtable.college==college).with_entities(func.round(func.avg(Bigtable.zh_score),2)).scalar()
    term1_score = Bigtable.query.filter(Bigtable.college==college, and_( Bigtable.year==year,Bigtable.semester==term_names['term1'])).with_entities(func.round(func.avg(Bigtable.zh_score),2)).scalar()
    term2_score = Bigtable.query.filter(Bigtable.college==college, and_( Bigtable.year==year,Bigtable.semester==term_names['term2'])).with_entities(func.round(func.avg(Bigtable.zh_score),2)).scalar()

    组装数据返回
    return {
        'basicCard':{
            'year_score':year_score,
            'term1_score':term1_score,
            'term2_score':term2_score
        },
        'indexes':indexes,
        'gpa_score':gpa_score,
        'range':{
            'ranges':range_text,
            'term1_scores':term1,
            'term2_scores':term2
        },
        'top':top,
        'trend':{
            'years':years,
            'term1':term1_trend,
            'term2':term2_trend
        }

    }
```

### 前后端连接

>后端api接口编写完后,前端可以使用ajax请求真实数据,将测试数据替换为真实数据

请求真实数据(`src\components\Logo.vue`),将真实数据显示在图表上
```js
    requestCollege() {

      post("/api/collage", {
        college:this.collegename,
        year: store.state.year,
        term: store.state.term
      })
        .then(res => {

          // 测试数据和请求的后台数据结构一样，直接合并，后台有的直接替换，没有的显示为测试数据
          Object.assign(college, res);
          EventBus.$emit("collegeDataLoad", college);
        })
        .catch(err => {
          console.warn("请求学院界面数据失败,发送测试数据...>>>");
    
          this.showFailDialog("获取学院数据失败:\n" + err, this.selectYear);
          //设置成测试数据
          //发送事件
          this.loading = false;
          // 请求失败也显示测试数据
          EventBus.$emit("collegeDataLoad", college);
        });
    }
```


## 可视化导航组件

因为展示的页面需要切换不同年度，不同学期的数据,这些通用的切换选择框学院、班级和学生页面都需要。

将这个封装成一个组件，放在`<router-view>`同级的地方(`App.vue`)，无论`<router-view>`切换成学院、班级还是其他页面,导航都始终在上面。

![导航图](导航组件.png)

### 导航功能

- 切换年度数据
- 切换学期数据
- 进入班级界面

### 导航生命周期
  1. 页面进入请求可用的年度数据和当前年度班级数据
  2. 年度或者选择框改变，通知二级组件重新请求数据,更新页面
  3. 切换到非可视化页面，隐藏导航
  4. 
### 请求数据流程
  - 监听请求事件
  
  因为只有可视化页面需要导航,所以只有在接收到指定事件`requestData`时才会请求导航数据
  监听`requestData`事件,这个事件只有可视化页面会发出，接受到后调用`requestNav`函数请求导航数据

  监听事件代码(`src\components\Logo.vue`)
  ```js
       EventBus.$on("requestData",(from)=>{
            console.log(`来自:${from}的请求重新加载数据事件`)
            // 先请求导航里的数据
            this.requestNav()
        })
  ```
  - 可视化页面发送`requestData`事件
    例如学院界面(`src\views\College.vue`)在`mounted`时发送事件，请求数据
    ```js
      mounted(){
       ....省略
    //显示加载数据和初始化图表
    this.showLoad()
    //发送请求给Logo组件，请求学院数据,请求响应后再上面的监听里可用监听
    EventBus.$emit("requestData","学院")
    },
    ```
  - 请求导航数据
    接收到 `requestData`事件后就开始请求导航数据,`requestNav`函数为请求年度和班级数据的函数,请求成功后会继续请求可视化页面的数据
    ```js
      requestNav() {
      // 显示全局加载条
      this.loading = true;
      // 学年数据,包括所有年份,这个年度的所有班级，
      apiLogoNav({
        college:this.collegename
      })
        .then(res => {
          ....省略
          请求成功后请求可视化页面的数据
          // 请求学院或者班级的数据
          this.selectYear();
        })
        .catch(err => {
          this.loading = false;
          this.showFailDialog("加载年度和班级列表数据失败!!", this.requestNav);
          // 加载失败也继续 请求数据
          this.selectYear();
        });
    },
    ```
  - 判断当前不同的路由，请求对应的数据
    由于可视化界面有多个,需要判断不同的路由来发送不同的请求
    判断路由代码如下
    ```js
      selectYear() {
      this.showSelect = true;
      console.log("当前路由:");
      console.log(this.$router.currentRoute);
      //根据当前路由的不同，请求不同的数据
      console.log("选择的year:" + this.year + " term:" + this.term);
      store.setYear(this.year);
      store.setTerm(this.term);
      this.loading = true;
      //模拟延迟
        if (this.$router.currentRoute.name == "college") {
          this.requestCollege();
        } else if (this.$router.currentRoute.name == "class") {
          //获取当前路由的参数，传给请求数据函数
          let classid = this.$router.currentRoute.params["classid"];

          this.requestClass(classid);
        } else if (this.$router.currentRoute.name == "student") {
          
          this.requestStudent(
            this.$router.currentRoute.params["studentid"],
            this.$router.currentRoute.params["classid"]
          );
        }
        //什么都不是
        //选择的
        else {
          this.loading = false;
        }
      }
    ```
  - 发送对应页面的图表事件到对应页面
    导航请求数据成功后，发送`collegeDataLoad`事件,可视化页面监听`collegeDataLoad`事件,将接收到的数据显示到页面
    ```js
      导航发送数据完成事件
          requestCollege() {

      post("/api/collage", {
        college:this.collegename,
        year: store.state.year,
        term: store.state.term
      })
        .then(res => {
          console.log("请求学院数据成功:..");
          console.log(res);
          this.loading = false;
          // 测试数据和请求的后台数据结构一样，直接合并，后台有的直接替换，没有的显示为测试数据
          Object.assign(college, res);
          EventBus.$emit("collegeDataLoad", college);
        })
      可视化页面监听到请求数据完成
      EventBus.$on("collegeDataLoad",data=>{
        ....省略 ,设置数据到图表
      //隐藏所有图表的加载动画
      this.hideLoad()
      
    })
    ```

## 用户登录注册

### 未登录拦截
  
只有登录了才可以看到`可视化页面`和`数据管理页面`，如果没有登录会自动重定向到登录

需要前后端配合，前端拦截请求头添加cookies,后端验证。

后端使用`flask_login`的Flask 扩展实现登录功能,可以通过在需要登录才能看到的路由添加`@login_required`装饰器，前请求时如果没有登录会返回`401`状态码

如请求班级数据时需要验证登录(`zhsz_api\controllers\logonav.py`)
```python
# 查询数据库里所有的班级
@api_blue.route("/nav/classes",methods=['POST'])
@login_required
def get_classes():
    formdata = request.json
```

访问`get_classes`路由时登录和未登录的返回值
- 未登录
    ```html
      HTTP/1.0 401 UNAUTHORIZED
    Content-Type: text/html
    Content-Length: 338
    Access-Control-Allow-Origin: *
    Vary: Cookie
    Server: Werkzeug/0.16.0 Python/3.7.3
    Date: Thu, 28 Nov 2019 02:46:37 GMT

    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
    <title>401 Unauthorized</title>
    <h1>Unauthorized</h1>
    <p>The server could not verify that you are authorized to access the URL requested. You either supplied the wrong credentials (e.g. a bad password), or your browser doesn't understand how to supply the credentials required.</p>
    ```

- 登录
  
    ```js
    HTTP/1.0 200 OK
  Content-Type: application/json
  Content-Length: 3001
  Access-Control-Allow-Origin: *
  Vary: Cookie
  Server: Werkzeug/0.16.0 Python/3.7.3
  Date: Thu, 28 Nov 2019 02:48:33 GMT

  {
    "data": {
      "classes": [
        {
          "children": [
            {
              "children": [
                {
                  "label": "1",
                  "value": "1"
    ```

- 前端通过`axios`的全局拦截器拦截，任何请求返回`401`都会重定向登录界面
  前端拦截器关键代码(`src\api\http.js`)
 ```js
  // response 拦截，所有的请求回应都会通过这里
axios.interceptors.response.use(response => {

    if (response.status === 200)
        return Promise.resolve(response)
    else
        return Promise.reject(response)
}, err => {
  ...省略
    switch (err.response.status) {
        //没有登录,重定向到登录界面
        case 401:
            Message({
                type: "error",
                message: "没登录，重定向到登录界面"
            })
            router.replace({ name: "login" })
            break
            .....
    }`
  ```

## 数据导入,数据解析 功能

### 数据导入流程

1. 前端上传Excel文件,如`2018-2019学年度第二学期学生综合素质测评分（2018级）.xls`
2. 后台根据选择的Excel的数据信息(年份，年级等),用指定文件名保存
3. 前端请求解析数据,解析Excel并保存数据到数据库

### 前端文件处理

- 识别文件名，自动选择选项框
  因为一个Excel为某个学院某个年度某个学期某个年级的综合素质数据,上传一个Excel需要在前端指定当前数据的`学院`,`年度`，`学期`，`年级`

  选择文件后,会尝试解析文件名来自动选择四个选择框,如果文件名符合`xxxx-yyy学年度第X学期学生综合素质测评分（zzzz级）.xls`级的规则，会从文件名里提取出四个值
  文件名里通过正则表达式需要的数据代码(`src\views\Data.vue`)
  ```js
        let grade_pattern =/(\d+)级/g
        let term_pattern= /第(.)学期/g
        let year_pattern=/(\d{4})-\d{4}/g
        let grade=grade_pattern.exec(name)
        let term = term_pattern.exec(name)
        let year = year_pattern.exec(name)
  ```
### 上传文件名规范

文件上传后,不会立即解析到数据库，而是保存在服务器，等待用户在前端点击了`解析数据`按钮后才会触发解析操作，把数据解析到数据库

文件上传后根据，文件的信息(年级，学期等)命名
后台文件名规范代码(`zhsz_api\controllers\data.py`)
```python
def getuploadpath(formdata):
    uploadfile ="{}-{}-{}-{}.xls".format(formdata['college'], formdata['year'], formdata['grade'], formdata['term'])
    datafile = "{}-{}-{}-{}.csv".format(formdata['college'],formdata['year'], formdata['grade'], formdata['term'])
    return os.path.join(UPLOAD_PATH ,uploadfile), os.path.join(UPDATA_PATH, datafile)
```
规范化后的文件名样例:`大数据与人工智能学院-2018-2017-term1.xls`

### 文件解析入库

解析Excel文件，将数据保存到mysql数据库中

解析代码`def handle_file()`函数(`zhsz_api\controllers\data.py`)

### 记录数据删除

删除的记录包括两个操作
- 删除excel文件
- 删除mysql数据库记录
  

## 其他
### 前后端跨域问题

跨域问题在前端开发调试时存在，在部署到后端时，直接部署在Flask下，是同域，就不存在跨域问题
由于浏览器的`同源策略`,开始调试时,前端项目运行在`http://localhost:8080`,后台Flask api 服务器运行在`http://127.0.0.1:5000/`，同源是指域名，协议，端口相同。这里端口不一样,前端`ajax`请求时会失败

解决方法为,在前端开发时配置代理服务器，代理服务器将请求转发到Flask后台

代理服务器配置代码(`vue.config.js`),所有`/api`开头的请求都会被转发到`http://localhost:5000`
```js
      devServer: {
        open: true,
        host: 'localhost',
        port: '8080',
        //将api下的请求代理到localhost:500下
        proxy: {
          '/api': {
            target: 'http://localhost:5000', // 要请求的地址
            ws: true,

            changeOrigin: true
          }
        }
      }
```

## 项目编译部署

### 部署流程
- 编译前端代码
前端项目编译生成压缩好的静态文件
编译命令 `npm run build`
- 部署编译的工程到Flask项目中
  将编译输出的`dist`目录作为flask的静态目录，访问`index.html`就会返回前端代码
### 前端编译

运行编译命令后，会在项目的前端根目录生成`dist`文件夹
编译输出的文件
📦dist
 ┣ 📂css
 ┃ ┣ 📜app.5642837f.css
 ┃ ┗ 📜chunk-vendors.8f69c8d0.css
 ┣ 📂fonts
 ┃ ┣ 📜element-icons.535877f5.woff
 ┃ ┗ 📜element-icons.732389de.ttf
 ┣ 📂img
 ┃ ┣ 📜44ce51cbfee3ac0249cd771f2ad9a7c2.1237196c.jpg
 ┃ ┣ 📜ba8bd4e0f53dbde0eedb58c571a98202.47bc6eca.jpg
 ┃ ┣ 📜kk.f9fde43d.png
 ┃ ┗ 📜mouse.dbd8f926.png
 ┣ 📂js
 ┃ ┣ 📜app.fca29a54.js
 ┃ ┣ 📜app.fca29a54.js.map
 ┃ ┣ 📜chunk-vendors.7849c5fa.js
 ┃ ┗ 📜chunk-vendors.7849c5fa.js.map
 ┣ 📜favicon.ico
 ┣ 📜index.html
 ┗ 📜logo.jpg

 ### 拷贝`dist`到Flask目录
